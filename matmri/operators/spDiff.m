function y = spDiff(u,transp,dimScale,imMask)
%
% y = spDiff(u,transp,sz_im,dimScale)
%
%   Estimate circular spatial difference of images along specified dimensions
%
%   u: image or spDiff of image
%   transp: 'transp' or 'notransp'
%   dimScale: vector with length = number of image dims. 
%         Only dims values ~= 0 will have diff computed.
%         The diff for each dim is scaled by dimScale
%   imMask (optional): image mask
%
% (C) Corey Baron 2018
%

if nargin == 0
    spDiff_unittest;
    return;
end
if nargin<5
    imMask = [];
end


% Perform the operations
switch transp
    case 'notransp'
        % Determine sizes, accounting for how matlab handles vectors
        sz_im = size(u);
        if sz_im(end)==1
            sz_im = sz_im(1:end-1);
        end
        ndims_im = length(sz_im);
        % Perform diff over each dimension
        y = zeros([sz_im sum(dimScale~=0)], 'like', u);
        if ~isempty(imMask)
            u = u.*imMask;
        end
        n = 1;
        for m=1:ndims_im
            if dimScale(m) ~= 0           
                switch(m)
                    case 1
                        catVals = u(end,:,:,:,:,:);
                    case 2
                        catVals = u(:,end,:,:,:,:);
                    case 3
                        catVals = u(:,:,end,:,:,:);
                    case 4
                        catVals = u(:,:,:,end,:,:);
                    case 5 
                        catVals = u(:,:,:,:,end,:);
                end
                tmp = cat(m,catVals,u);
                tmp = dimScale(m)*diff(tmp,1,m);
                switch ndims(u)
                    case 1
                        y(:,n) = tmp;
                    case 2
                        y(:,:,n) = tmp;
                    case 3
                        y(:,:,:,n) = tmp;
                    case 4
                        y(:,:,:,:,n) = tmp;
                    case 5
                        y(:,:,:,:,:,n) = tmp;
                    otherwise
                        error('input to spDiff too many dimensions!')
                end
                n=n+1;
            end
        end

    case 'transp'
        % Determine sizes, presuming input was generated by 'notransp'
        % version of this function
        sz_im = size(u);
        if sz_im(end)==1
            sz_im = sz_im(1:end-1);
        end
        ndims_im = length(sz_im);
        if sum(dimScale) > 1
            sz_im = sz_im(1:end-1);
            ndims_im = ndims_im - 1;
        end
        % Determine adjoint of differences, which is more differences
        y = zeros([sz_im, 1], 'like', u);
        n=1;
        for m=1:ndims_im
            if dimScale(m) ~= 0
                switch(m)
                    case 1
                        catVals = u(1,:,:,:,:,:);
                    case 2
                        catVals = u(:,1,:,:,:,:);
                    case 3
                        catVals = u(:,:,1,:,:,:);
                    case 4
                        catVals = u(:,:,:,1,:,:);
                    case 5 
                        catVals = u(:,:,:,:,1,:);
                end
                switch ndims_im
                    case 1
                        tmp = cat(m,u(:,n),catVals(:,n));
                    case 2
                        tmp = cat(m,u(:,:,n),catVals(:,:,n));
                    case 3
                        tmp = cat(m,u(:,:,:,n),catVals(:,:,:,n));
                    case 4
                        tmp = cat(m,u(:,:,:,:,n),catVals(:,:,:,:,n));
                    case 5
                        tmp = cat(m,u(:,:,:,:,:,n),catVals(:,:,:,:,:,n));
                    otherwise
                        error('input to spDiff too many dimensions!')
                end
                y = y - dimScale(m)*diff(tmp,1,m);
                n=n+1;
            end
        end
        if ~isempty(imMask)
            y = y.*imMask;
        end
    otherwise
        error('transp input must be ''transp'' or ''notransp''');
end
end


function spDiff_unittest
% Make sure it works with GPU
N = round(50*rand(1,3))+2;
dimsIn = [1 1 1];
u = randn([N,1]) + 1i*randn([N,1]) + randn;
Au1 = spDiff(u,'notransp',dimsIn);
ATAu1 = spDiff(Au1,'transp',dimsIn);
if gpuDeviceCount > 0
    u = gpuArray(u);
end
Au2 = spDiff(u,'notransp',dimsIn);
ATAu2 = spDiff(Au2,'transp',dimsIn);
assert(norm(Au1(:)-gather(Au2(:)))/numel(Au1) < 1e-10, 'FAIL: unit test of spDiff.m failed GPU test 1')
assert(norm(ATAu1(:)-gather(ATAu2(:)))/numel(ATAu1) < 1e-10, 'FAIL: unit test of spDiff.m failed GPU test 2')
% Test params
for Ndim = 1:4
    N = round(50*rand(1,Ndim))+2;
    dimsIn = ones(length(N),1);
    u = randn([N,1]) + 1i*randn([N,1]) + randn;
    if gpuDeviceCount > 0
        u = gpuArray(u);
    end
    spDiffu = spDiff(u,'notransp',dimsIn);
    sz = size(spDiffu);
    y = randn(sz) + 1i*randn(sz) + randn;
    spDiffTy = spDiff(y,'transp',dimsIn);
    d1 = dot(u(:),spDiffTy(:));
    d2 = dot(spDiffu(:),y(:));
    assert(norm(d1(:) - d2(:)) < 1e-8, 'FAIL: unit test of spDiff.m failed adjoint test 1')
    for nSel = 1:2*Ndim
        if nSel<=Ndim
            dimsIn = zeros(Ndim,1);
            dimsIn(nSel) = rand;
        else
            dimsIn = 0;
            while sum(dimsIn)==0
                dimsIn = round(rand(Ndim,1));
            end
        end
        spDiffu = spDiff(u,'notransp',dimsIn);
        sz = size(spDiffu);
        y = randn(sz) + 1i*randn(sz) + randn;
        spDiffTy = spDiff(y,'transp',dimsIn);
        d1 = dot(u(:),spDiffTy(:));
        d2 = dot(spDiffu(:),y(:));
        assert(norm(d1(:) - d2(:))/numel(u) < 1e-10, 'FAIL: unit test of spDiff.m failed adjoint test 2')
    end
end
fprintf('spDiff.m unit tests successful\n')
end
